07 문자/숫자/날짜 함수
문자함수
예제01 SELECT ID, NAME, LOWER(NAME) AS NAME_SMALL FROM VENDOR_INFO;
예제02 SELECT ID, NAME, UPPER(NAME) AS NAME_CAP FROM VENDOR_IFNO;
예제03 SELECT ID, NAME, LENGTH(NAME) AS NAME_CNT FROM VENDOR_INFO;
예제04 SELECT ID, NAME, SUBSTR(NAME,1,3) AS NAME_STR FROM VENDOR_INFO;
숫자함수
ROUND TRUNC MOD(M,N) ABS SIGN SQRT COS SIN SAN PI
ROUND TRUNC MOD(M,N)
SELECT PROD_ID, TOTAL_SALES, ROUND(TOTAL_SALES,2) AS SALESS_REV FROM PROD_SALES; #1임
SELECT PROD_ID, TOTAL_SALES, ROUND(TOTAL_SALES, 0) AS SALES_REV FROM PROD_SALES;
SELECT PROD_ID, TOTAL_SALES, ROUND(TOTAL_SALES, -2) #-1임 
SELECT PROD_ID, TOTAL_SALES, SALES_NUM, MOD(TOTAL_SALES,SALES_NUM) AS SALES_BALANCE FROM PROD_SALES;
SELECT PROD_ID, ECON_INCOME, ABS(ECON_INCOME) AS PRFT FROM PROD_SALES;

실습
01 SELECT RESIENCE_ID, (RESIDENCE_ID LIKE 8% = 1, RESIDENCE_ID LIKE 7% = 2) AS GENDER FROM CUST_INFO;
SUBSTR(RESIDENCE_ID, 1)
#SUBSTR(RESIDENCE_ID,7,1)
02 SELECT TRIM(LAST_NM)||', '||TRIM(FIRST_NM) AS FLL_NM FROM CUST_INFO;
03 SELECT RESIDENCE_ID, ROUND(ANNL_PERF,1) AS NEW_ANNL_PERF FROM CUST_INFO;

08 
case when then
02 SELECT ID, JOB, CURRNET_SAL, ENG_SCORE
        CASE WHEN JOB='CLERK' AND ENG_SCORE >= 80 THEN CURRENT_SAL*10.7
             WHEN JOB='CLERK' AND ENG_SCORE < 80  THEN CURRENT_SAL*1.06
             WHEN JOB='OFFICIER' AND ENG_SCORE >= 80 THEN CURRENT_SAL*1.05
             WHEN JOB='OFFICIER' AND ENG_SCORE < 80  THEN CURRENT_SAL*1.04
             WHEN JOB='MANAGER' AND ENG_SCORE >= 80  THEN CURRENT_SAL*1.03
             WHEN JOB='MANAGER' AND ENG_SCORE < 80  THEN CURRENT_SAL*1.02
             ELSE CURRENT_SAL
             END AS NEXT_SAL
   FROM STAFF_SAL;

03 SELECT SUM(NEXT_SAL
        CASE WHEN JOB='CLERK' AND ENG_SCORE >= 80 THEN CURRENT_SAL*10.7
             WHEN JOB='CLERK' AND ENG_SCORE < 80  THEN CURRENT_SAL*1.06
             WHEN JOB='OFFICIER' AND ENG_SCORE >= 80 THEN CURRENT_SAL*1.05
             WHEN JOB='OFFICIER' AND ENG_SCORE < 80  THEN CURRENT_SAL*1.04
             WHEN JOB='MANAGER' AND ENG_SCORE >= 80  THEN CURRENT_SAL*1.03
             WHEN JOB='MANAGER' AND ENG_SCORE < 80  THEN CURRENT_SAL*1.02
             ELSE CURRENT_SAL END 
             AS NEXT_SAL ) - SUM(CURRENT_SAL) AS ADD_BUDGET
  FROM STAFF_SAL;
# SUM ( NEXT SAL CASE WHEN... 에서 NEXT SAL 을 정의할 필요가 없었다 해야하나 . 그리고 없는 문법 같음

실습01
SELECT CUST_ID, CUST_SEG, BALANCE_201311, BALANCE_201312,
        CASE WHEN BALANCE_201311*1.1<=BALANCE_201312 THEN 1
             ELSE 0 END AS OFFER_ACCEPT
FROM CASA_201312;

실습02
SELECT COUNT(*) AS LEAD_CNT, 
        SUM(CASE WHEN BALANCE_201311*1.1<=BALANCE_201312 THEN 1 ELSE 0 END) AS OFFER_ACCEPT, 
        OFFER_ACCEPT/LEAD_CNT*100 AS RES_RATE
FROM CASA_201312;

실습03
SELECT SUM(BALANCE_201311)AS BAL_1311, SUM(BALANCE_201312) AS BAL_1312, (SUM(BALANCE_201312)-SUM(BALANCE_201311)) AS INC_BAL, SUM(BALANCE_201311)*0.9 AS REV
FROM CASA_201312;
?

09
예제1
01
SELECT SEG, SUM(CASE WHEN SEG='DIAMOND' THEN ANNL_REV WHEN SEG='GOLD' THEN ANNL_
NO
SELECT GENDER, AVG(ENG) AS ENG_SCORE, AVG(MATH) AS MATH_SCORE
SELECT SEG, AVG(ANNL_REV)
FROM PPC_201312
GROUP BY SEG;

02 
SELECT SEG, COUNT(CUST_ID) AS CNT, SUM(CARD_FLG) AS CARD_FLG
FROM PPC_201312
GROUP BY SEG;

03
SELECT CARD_FLG, LOAN_FLG,
        SUM(CASE WHEN CARD_FLG=0 AND LOAN_FLG=0 THEN 1,
                 WHEN CARD_FLG=1 AND LOAN_FLG=0 THEN 1,
                 WHEN CARD_FLG=1 AND LOAN_FLG=0 THEN 1,
                 ELSE 0 END) AS CNT
FROM PPC_201312 
GROUP BY CARD_FLG, LOAN_FLG;
GROUP BY 1,2;

실습
01
SELECT CASE WHEN ADD_CD IN (100,110,120,130,140) THEN ASSET
            WHEN ADD_CD IN (300,310,320,330,340) THEN LIABILITY
        END AS BALANCE_SHEET,
        SUM(BALANCE_AMT) AS TOTAL_BALANCE_AMT
FROM PPC_MAST_201312
GROUP BY 1;

02
SELECT SSN, COUNT(*) AS CNT
FROM PPC_MAST_201312
GROUP BY SSN;

03
SELECT SSN, COUNT(*) AS PPC
FROM PPC_MAST_201312
GROUP BY SSN
HAVING COUNT(*)>2
ORDER BY 1;

04 
SELECT SSN, COUNT(*) AS PPC, SUM(PRFT) AS PRFT)
FROM PPC_MAST_201312
GROUP BY 1
ORDER BY 1;


SELECT SEG, COUNT(*) AS CNT, SUM(CARD_FLG) AS CARD_CNT
GROUP BY SEG


10 테이블 합치기
내부조인
02
SELECT TMP1,TMP2,TMP3
FROM CUSTOMERS TMP1, ORDERS TMP2, EMPLOYEE TMP3
WHERE TMP1.CUST_ID=TMP2.CUST_ID, TMP2.EMP_ID=TMP3.EMP_ID;
#SELECT에 KEY값 빠짐
#WHERE의 경우 AND로 연결해줘야하는데 나열했음

SELECT TMP1, TMP2, TMP3
FROM CUSTOMERS TMP1 INNER JOIN ORDERS TMP2 ON TMP1.CUST_ID=TMP2.CUST_ID
     ORDERS         INNER JOIN EMPLOYEE TMP3 ON TMP2.EMP_ID=TMP3.EMP_ID;
#SELECT KEY값 빠짐
#INNER JOING으로 연결할때: 처음 주인공 앞에 잡고 거기에다가 INNER JOIN으로 하나씩 붙이면 됨. WHERE처럼 주이곤 이름을 여러번 불러줄 필요가 없음
#OMG 잘못생각 - 애초에 TMP1과2 연결 후 TMP2와 연결
-> 생각해보니까 꼭 테이블 이름을 한번씩 붙여서 나열해준 후에, ON에서 KEY값 동일하다고 알려줘야하는 게 아니잖아
-> FROM/WHERE조건절은 FROM에서 테이블&별칭 다 나열한 후 WHERE에서 결합조건 차례로 AND로 연결하는데
-> FROM+INNER JOIN +ON 에서는 첫번째꺼는 테이블&별칭 써준 후, [INNER JOIN 누구(별칭!)] 로 테이블 등장시키면서, [ON TMP3.KEY = TMP2.KEY]로 어떤 테이블이랑 쪼인할 것인지 알려줌

SELECT TMP1.CUST_ID, TMP1. CUST_NM, TMP2.ORDER_ID, TMP2.EMP_ID, TMP3.NM
FROM CUSTOMERS TMP1 INNER JOIN ORDERS TMP2   ON TMP1.CUST_ID=TMP2.CUST_ID
                    INNER JOIN EMPLOYEE TMP3 ON TMP2.EMP_ID=TMP3.EMP_ID;

외부조인
#왼쪽 테이블 기준으로 조인하는 방법 - 키값중 왼쪽 테이블에 존재하는데, 오른쪽 테이블에 존재하지 않아? NULL값으로 반환
SELECT 별칭1.열이름1, 별칭2.열이름2
FROM 테이블명 별칭1 LEFT (OUTER) JOIN 테이블명2 별칭2
                   ON                별칭1.KEY = 별칭2.KEY;

#오른쪽 테이블 기준으로 조인
SELECT 별칭1.열이름, 별칭2.열이름...
FROM 테이블명.별칭1 RIGHT (OUTER)JOIN 테이블명.별칭2 ON 별칭1.KEY=별칭2.KEY

예제
01
SELECT TMP1.CUST_ID, TMP1.CUST_NM, TMP2.ORDER_ID, CASE WHEN TMP2.ORDER_ID IS NOT NULL THEN 1 ELSE 0 END AS ORDER FLG
FROM CUSTOMERS TMP1 LEFT JOIN ORDERS TMP2 ON TMP1.CUST_ID = TMP2.CUST_ID
ORDER BY 1;

#방법2 RIGHT OUTER JOIN 사용하기
SELECT TMP1.CUST_ID, TMP1.CUST_NM, TMP2.ORDER_ID, CASE WHEN TMP2.ORDER_ID IS NOT NULL THEN 1 ELSE 0 END AS ORDER FLG
FROM ORDERS TMP2 RIGHT JOIN CUSTOMERS TMP1 ON TMP1.CUST_ID = TMP2.CUST_ID
ORDER BY 1;

SELECT TMP2.CUST_ID, TMP2.CUST_NM, TMP1.ORDER_ID, CASE WHEN TMP1.ORDER_ID IS NOT NULL THEN 1 ELSE 0 END AS ORDER FLG
FROM ORDERS TMP1 RIGHT JOIN CUSTOMERS TMP2 ON TMP1.CUST_ID = TMP2.CUST_ID
ORDER BY 1;

예제
02
SELECT CASE WHEN TMP2.ORDER_ID IS NOT NULL THEN 1 ELSE 0 END AS ORDER_FLG, COUNT(*)AS CNT
FROM CUSTOMERS TMP1 FULL JOIN ORDERS TMP2 ON TMP1.CUST_ID=TMP2.CUST_ID
GROUP BY ORDER_FLG;

#그룹바이에서 약어 써도 되는건지 의문 -> 안되니까 얄위치 1로!!

실습
01
#고민. INNER로 공통을 찾는게 아니라면.. 수신테이블이 있는 사람을 찾는거니가 두번째 테이블을 메인으로 삼자
SELECT TMP1.SSN, TMP2.MOBILE_NO, COUNT(*)AS CNT
FROM RCPT_ACCT TMP1 LEFT OUTER JOIN CUST_PARTY TMP2 ON TMP1.SSN = TMP2.SSN
GROUP BY TMP1.SSN, TMP2.MOBILE_NO
ORDER BY 3;
#완전틀림

SELECT SSN, COUNT(*)AS CNT 
FROM RCPT_ACCT WHERE 
WHERE CLCN_DT IS NULL 
GROUP BY 1

SELECT TMP1.SSN, TMP1.MOBILE_NO, TMP2.CNT
FROM CUST_PARTY TMP1 
        LEFT OUTER JOIN (SELECT SSN, COUNT(*) AS CNT FROM RCPT_ACCT WHERE CNCL_DT IS NOLL GROUP BY SSN) TMP2
        ON TMP1.SSN = TMP2.SSN
WHERE CNT>=1
ORDER BY 3;

03
SELECT TMP1.SSN, TMP1.PARTY_NM, TMP1.MOBILE_NO, TMP2.CNT, TMP2.RCPT_AMT
FROM CUST_PARTY TMP1
LEFT OUTER JOIN ( SELECT SSN, COUNT(*)AS CNT, SUM(RCPT_AMT) AS RCPT_AMT FROM RCPT_ACCT GROUP BY 1 ) TMP2
ON TMP1.SSN = TMP2.SSN
WHERE TMP2.CNT >=2 AND TMP2.RCPT_AMT > 500000
ORDER BY 1;
